# LeetCode 2289. 使数组按非递减顺序排列

题目需要求需要多少步骤完成操作, 观察其过程:  
在每个可以进行的步骤完成时, 总会移除一些特定的元素。

步骤1移除的元素, 可视为这些元素只存活了1代。  
步骤2移除的元素, 可视为这些元素只存活了2代。  
以此类推...

最终结果则等价为除必定幸存的元素外, 存活最久元素

## 模拟/数组

设`gens`为元素的存活状况, `gens[i]`表示`nums[i]`最终存活的代数。  
若`nums[i]`最终幸存, 则`gens[i]`标记为`n`

- i = 0时

`nums[0]`没有前一项元素比较, 必定幸存, 则`nums[0]`=`n`

- i > 0时, 设 j < i

`nums[i]`不断与`nums[j]`比较, 比较次数越多, 则`gens[i]`越大。

若`nums[j]` <= `nums[i]`, 则`gens[j]` <= `gens[i]`  
存活代数每次比较成功+1, 为了压缩累加次数, 每次比较成功后, 则跳转可用前项的最后一代。

因此设`prevs[i]`, 为`nums[i]`比较的最后一项下标。  
接着就可以开始模拟整个比较过程。

如示例, [5,3,4,4,7,3,6,11,8,5,11]

i = 0, 没有比较对象, 则
```
prevs = [-1]
gens  = [ 0]
```

i = 1, `nuns[i]` = 3, 第1轮淘汰
```
prevs = [-1, 0]
gens  = [ 0, 1]
```

i = 2, 第1轮存活, 第2轮通过`prevs[1]`比较`nums[0]`失败
```
prevs = [-1, 0, 0]
gens  = [ 0, 1, 2]
```
以此类推

```
nums  = [5,  3, 4, 4,  7, 3, 6, 11,8,5,11]
prevs = [-1, 0, 0, 0, -1, 4, 4, ...]
gens  = [ n, 1, 2, 4,  n, 1, 2, ...]
```

`gens[j]` >= `gens[i]`, 则表示双方可以存活到相互比较时刻, 触发比较逻辑。  
出现无法比较的情况时, 则直接通过`prevs[j]`跳转, 寻找可比较元素。

## 栈

通过上面的模拟, 可以得知`nums[i]`确定时, 后续任何`nums[k]`, k>i, 都无法影响先前的状态。  
若`nums[u]`, `nums[v]`, 为最终存活元素, 则只有`(u, v)`间的元素才能影响结果

再结合上面的模拟, 相互比较条件只有`nums[i]`本身的`大小`与存活的`代数`。  
确定条件后, 剩余的操作就是过滤无用的状态。

以`n`表示元素值, `g`表示存活代数, 最终幸存则g=nums.size, 计为`s`
则示例[5,3,4,4,7,3,6,11,8,5,11]如下:

i = 0
```
n = [5]
g = [s]
```

i = 1
```
n = [5, 3]
g = [s, 1]
```

i = 2, 掠夺3的存活代数
```
n = [5, 4]
g = [s, 2]
```
以此类推

`n`较大的时候可以掠夺`g`, `g`较大则直接出栈
